# 前言

很久以前练手写的小笔记，保留仅为纪念意义。

虽然我的水平依然停留在能被随机抽取的路人秒杀的蒟蒻水平，但还是希望能用这种微不足道的东西鼓励一下自己。也当是一种费曼学习法或者说是复习了？

如果你也深陷这种自卑、焦虑的泥潭，希望能与君共勉。（也许写这种东西也是一种止痛药，给自己一种在努力的错觉吧...）

事不宜迟，现在开始！

~~警告：请在看笔记前阅读~~

~~当暴露在特定光影图案或闪光光亮下时，有极小部分人群会引发癫痫。这种情形可能是由于某些未查出的癫痫症状引起，即使该人员并没有患癫痫病史也有可能造成此类病症。如果您的家人或任何家庭成员曾有过类似症状，请在进行游戏前咨询您的医生或医师。如果您在阅览过程中出现任何症状，包括头晕、目眩、眼部或肌肉抽搐、失去意识、失去方向感、抽搐、或出现任何自己无法控制的动作，请立即停止阅览并在继续阅览前咨询您的医生或医师。~~

~~**至理名言：放弃智力就会获得更强大的力量！**~~

# 1.搜索与回溯

以走迷宫为例子

---

## 1.迷宫寻路

https://www.luogu.com.cn/problem/B3625

### 题目描述

机器猫被困在一个矩形迷宫里。

迷宫可以视为一个 $n\times m$ 矩阵，每个位置要么是空地，要么是墙。机器猫只能从一个空地走到其上、下、左、右的空地。

机器猫初始时位于 $(1, 1)$ 的位置，问能否走到 $(n, m)$ 位置。

### 输入格式

第一行，两个正整数 $n,m$。  

接下来 $n$ 行，输入这个迷宫。每行输入一个长为 $m$ 的字符串，`#` 表示墙，`.` 表示空地。

### 输出格式

仅一行，一个字符串。如果机器猫能走到 $(n, m)$，则输出 `Yes`；否则输出 `No`。

### 样例 #1

### 样例输入 #1

```
3 5
.##.#
.#...
...#.
```

### 样例输出 #1

```
Yes
```

### 提示

#### 样例解释

路线如下：$(1,1)\to (2,1) \to (3,1) \to (3,2)\to (3,3) \to (2, 3) \to (2, 4) \to (2, 5) \to (3, 5)$

#### 数据规模与约定 

对于 $100\%$ 的数据，保证 $1 \leq n, m \leq 100$，且 $(1,1)$ 和 $(n, m)$ 均为空地。

---

### ==分析==

虽说用回溯会TLE，但是思路最重要！

↓↓TLE的代码

```cpp
#include<iostream>
using namespace std;
int n, m;
char arr[101][101];
bool search(int x, int y) {
	if (x == n && y == m) {
		return 1;
	}
	else {
		if (arr[x - 1][y] == '.') {
			arr[x][y] = 'x';
			if (search(x - 1, y)) return 1;
			arr[x][y] = '.';
		}
		if (arr[x + 1][y] == '.') {
			arr[x][y] = 'x';
			if (search(x + 1, y)) return 1;
			arr[x][y] = '.';
		}
		if (arr[x][y - 1] == '.') {
			arr[x][y] = 'x';
			if (search(x, y - 1)) return 1;
			arr[x][y] = '.';
		}
		if (arr[x][y + 1] == '.') {
			arr[x][y] = 'x';
			if (search(x, y + 1)) return 1;
			arr[x][y] = '.';
		}
	}
	return 0;
}

int main() {
	cin >> n >> m;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			cin >> arr[i][j];
		}
	}
	if (!search(1, 1))cout << "No";
	else cout << "Yes";
	system("pause");
}
```

search函数工作的顺序：

首先，判断脚下这一格是不是终点，如果是，则return 1

如果不是，则对四个方向进行尝试，

如果某一个方向是可以走的，那标记脚下那一格为走过的格子，并且移动到可以走到的那一格，并以走到的那一格为脚下，再次运行search函数

如果再次运行的search函数走不通，那么跳出再次运行的search函数，回到一开始站到的那一格，重新把这一格标记为没走过，再对其他方向进行尝试

如果四个方向的尝试全部木大，则返回0，最后根据返回的结果进行输出yes or no

(之所以使用标记、回溯，是为了防止出现循环转圈的情况，也就是绕了一圈结果回到了走过的地方，死循环。)

~~蒟蒻疑问：为什么这题不回溯就能AC，回溯就会TLE？？？~~

---

---

---

# 2.背包

~~我不会背包！看不懂啊！~~

背包是动态规划里面很经典的一类问题

---

## 1.[NOIP2005普及组] 采药

https://www.luogu.com.cn/problem/P1048

### 题目描述

辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”


如果你是辰辰，你能完成这个任务吗？

### 输入格式

第一行有 $2$ 个整数 $T$（$1 \le T \le 1000$）和 $M$（$1 \le  M \le 100$），用一个空格隔开，$T$ 代表总共能够用来采药的时间，$M$ 代表山洞里的草药的数目。

接下来的 $M$ 行每行包括两个在 $1$ 到 $100$ 之间（包括 $1$ 和 $100$）的整数，分别表示采摘某株草药的时间和这株草药的价值。

### 输出格式

输出在规定的时间内可以采到的草药的最大总价值。

### 样例 #1

### 样例输入 #1

```
70 3
71 100
69 1
1 2
```

### 样例输出 #1

```
3
```

### 提示

**【数据范围】**

- 对于 $30\%$ 的数据，$M \le 10$；
- 对于全部的数据，$M \le 100$。

**【题目来源】**

NOIP 2005 普及组第三题

### ==分析==

这是一道01背包题。

所谓01背包，就是有n个物品，V容量的背包，每个物品都有它的大小和价值，有放和不放两种状态，求物品总大小不超过容量V，总价值最大的大小。

先看代码↓↓↓(远古时期写的，我自己都看不懂，不建议看。。)

```cpp
#include<iostream>
using namespace std;
int arr[101][2];
int T, m;
int value[101][1001];
void fun() {
	for (int i = 1; i <= m; i++) {
		for (int j = 1; j <= T; j++) {
			if (arr[i][0] > j)value[i][j] = value[i - 1][j];
			else value[i][j] = max(value[i - 1][j - arr[i][0]] + arr[i][1], value[i - 1][j]);
		}
	}
}
int main() {
	cin >> T >> m;
	for (int i = 1; i <= m; i++) {
		cin >> arr[i][0] >> arr[i][1];
	}
	fun();
	cout << value[m][T];
	system("pause");
}
```

![image-20231109171403762](C:\Users\81380\AppData\Roaming\Typora\typora-user-images\image-20231109171403762.png)

~~汗流浃背了吧？~~

把每种物品从1编号到n，开一个二维数组来记录他们的大小和价值，value[ m ] [ T ]代表着在只考虑前m件物品的情况下，背包容量为T时的最大价值

对于每种物品，在大小小于容积时，都有放和不放两种情况。

比如说，考虑第i件物品在j大小的背包里的情况，如果不放，那么就相当于只考虑前i-1件物品在j大小的背包里的情况，也就是

**value[ i ] [ j ]=value[ i-1 ] [ j ]**

如果放，那就是求j大小的背包放入这个物品以后剩余的空间能放下的东西的最大价值，也就是

**value[ i ] [ j ]=value[ i-1 ] [ j - 物品大小 ] + 物品价值**

而想要获得这个位置最优解，只需要求上述两种情况的最大值，也就是放与不放的最大值也就是对他们用一个max。



### 优化成两行

这样是一个01背包最基础的思考情况，那有没有什么优化的办法呢？

显然是有的，我们可以观察到实际上推出value[ i ] [ j ]只需要上一行的数据，也就是value[ i-1 ] [ x ] (此处x=0.1.2.3.....n)。

那么我们可以把这个数组的行数简化成2行，每次输入数据的时候只需要输入到 i%2 行里就可以，最后再输出m%2行V列的数字就可以了。

(代码就不放了懒得重新写了。。)

### 能不能更优呢？

我们可以观察到，其实每次推出value[ i ] [ j ]需要的数据是上一行的，而且一定是他左边的！所以只要保证推出它的数据是从上一轮推出来的就可以了！

**所以我们可以把value压成一维dp[ j ] ！**

那要怎么办呢？很简单，既然数据都是从左边来的，那我从最右边往最左边写，不就可以保证左边的数据肯定不是这一轮刚写上去的了吗？可喜可贺可喜可贺！请看代码↓↓↓

```cpp
#include<iostream>
using namespace std;
int t, m;
int dp[10000005];
int a[10005][2];
int main()
{
	cin >> t >> m;
	for (int i = 0; i < m; i++) {
		cin >> a[i][0] >> a[i][1];
	}
	for (int i = 0; i < m; i++) {
		for (int j = t; j >= 0; j--) {
			if(j - a[i][0]>=0)
			dp[j] = max(dp[j], dp[j - a[i][0]] + a[i][1]);
		}
	}
	cout << dp[t];
	system("pause");
}
```

如此简短，如此简洁！~~之前写这么繁复的代码究竟是为了什么？可恶，果然“放弃智力就会获得更强大的力量……”~~

---



## 2.疯狂的采药

https://www.luogu.com.cn/problem/P1616

### 题目背景

此题为纪念 LiYuxiang 而生。

### 题目描述

LiYuxiang 是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同种类的草药，采每一种都需要一些时间，每一种也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”

如果你是 LiYuxiang，你能完成这个任务吗？

此题和原题的不同点：

$1$. 每种草药可以无限制地疯狂采摘。

$2$. 药的种类眼花缭乱，采药时间好长好长啊！师傅等得菊花都谢了！

### 输入格式

输入第一行有两个整数，分别代表总共能够用来采药的时间 $t$ 和代表山洞里的草药的数目 $m$。

第 $2$ 到第 $(m + 1)$ 行，每行两个整数，第 $(i + 1)$ 行的整数 $a_i, b_i$ 分别表示采摘第 $i$ 种草药的时间和该草药的价值。

### 输出格式

输出一行，这一行只包含一个整数，表示在规定的时间内，可以采到的草药的最大总价值。

### 样例 #1

### 样例输入 #1

```
70 3
71 100
69 1
1 2
```

### 样例输出 #1

```
140
```

### 提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $m \le 10^3$ 。
- 对于 $100\%$ 的数据，保证 $1 \leq m \le 10^4$，$1 \leq t \leq 10^7$，且 $1 \leq m \times t \leq 10^7$，$1 \leq a_i, b_i \leq 10^4$。

### ==分析==

这是一道完全背包题，所谓完全背包也是从01背包衍生出来的一种题型，不同点就在于，完全背包里面的物品可以有无限个，而不是01背包那样的放或不放，而是不放、放一个、放两个……

可以观察到，这道题的数据量比上一道题大得多，像上一道题那样开dp二维数组肯定不行（我试过。。会报错）

那么，我们直接用上一道题优化成两行的思路来写，代码如下↓↓↓

```cpp
#include<iostream>
using namespace std;
int t, m;
int dp[2][10000005];
int a[10005][2];
int main()
{
	cin >> t >> m;
	for (int i = 1; i <= m; i++) {
		cin >> a[i][0]>>a[i][1];
	}
	for (int i = 1; i <= m; i++) {
		for (int j = 0; j <= t; j++) {
			int mmax = 0;
			for (int k = 0; k * a[i][0] <= j; k++) {
				if (mmax < max(dp[(i - 1) % 2][j], dp[(i - 1) % 2][j - k * a[i][0]] + k * a[i][1])) mmax = max(dp[(i - 1) % 2][j], dp[(i - 1) % 2][j - k * a[i][0]] + k * a[i][1]);
			}
			dp[i % 2][j] = mmax;
		}
	}
	cout << dp[m % 2][t];
	system("pause");
}
```

~~实际交上去以后发现有两个样本是TLE的！~~

和上面的01背包一样，只不过每格需要考虑的不只是放与不放，还需要考虑放几个的问题，那么可以写出这样的式子来：

如果不放i物品，那么

**dp[ i ] [ j ]=dp[ i-1 ] [ j ]**

如果放k个i物品，那么

**dp[ i ] [ j ]=dp[ i - 1 ] [ j - 大小 * k ] + 价值 * k**

然后依次取k=0，k=1........一直到大小乘以k大于容积为止

最后取这k个放了物品的数据和不放物品的数据，找他们的最大值就是dp[ i ] [ j ]的大小了。

再用上面的思路压成两行即可。

交上去，哇哦！![image-20231109174546295](C:\Users\81380\AppData\Roaming\Typora\typora-user-images\image-20231109174546295.png)

~~亻尔 女子~~

**TLE了！**~~快用你无敌的白金之星~~想想办法优化一下！

### 优化 #1

既然TLE了，那么肯定是样本量太大了导致跑了太多次！有没有什么办法能毙掉一些样本呢？

如果有两件物品，一件大小10价值1，一件大小1价值10，你会怎么放？

那肯定是塞爆物品2！

因此，可以在输入数据以后加一个判断，是否有这样的物品，和某个物品相比，大小大，价值低，如果有删掉他就可以了。

**但是！**这个办法只对一些数据有用，一些数据用这个办法甚至会**反向优化**！！

~~快去请那位！~~

### 优化 #2

仔细想想，上一道题的第二次优化，为什么我们要从右往左写？就是为了保证左边的数据都是上一轮写入的，保证每个物品一轮只有放或不放这两种情况。

**如果我想倒过来呢？**

如果从左往右写，就可以保证每次考虑dp[ j ]的时候所用到的数据都是这一轮给他的，也就是说，是在已经考虑过放还是不放这个物品的状态下推导出来的！又因为一件物品大小不能小于1，所以大小为1的背包最多放1个，大小为2的最多放两个，以此类推！所以也就不必考虑大小为1的背包放0个是最优解，大小为2的背包放2个是最优解的情况了！也就是说，如果大小为1的背包放0个是最优解，那么大小为2的背包只可能是放1个是最优解或者不放是最优解！

所以我们可以直接把上一道题的写数据顺序换一下，代码↓↓↓



```cpp
#include<iostream>
using namespace std;
int t, m;
int dp[10000005];
int a[10005][2];
int main()
{
	cin >> t >> m;
	for (int i = 0; i < m; i++) {
		cin >> a[i][0] >> a[i][1];
	}
	for (int i = 0; i < m; i++) {
		for (int j = 0; j >= t; j--) {
			if(j - a[i][0]>=0)
			dp[j] = max(dp[j], dp[j - a[i][0]] + a[i][1]);
		}
	}
	cout << dp[t];
	system("pause");
}
```

是的！只改了13行的0和t的位置！！！！！！！

~~之前的努力再次全部木大！！！~~

~~我们新式的一维数组果然已经完全超越了老式的二维数组！！~~

再次AC，可喜可贺可喜可贺！

---

